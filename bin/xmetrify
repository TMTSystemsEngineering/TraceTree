#! /usr/bin/perl
# License Terms
# 
# Copyright (c) 2006,2007,2008,2009,2010,2011,2012,2013, California 
# Institute of Technology ("Caltech").  U.S. Government sponsorship 
# acknowledged. 
# 
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without 
# modification, are permitted provided that the following conditions are 
# met: 
# 
# 
# *   Redistributions of source code must retain the above copyright 
#     notice, this list of conditions and the following disclaimer.
# 
# *   Redistributions in binary form must reproduce the above copyright 
#     notice, this list of conditions and the following disclaimer in the 
#     documentation and/or other materials provided with the distribution.
# 
# *   Neither the name of Caltech nor its operating division, the Jet 
#     Propulsion Laboratory, nor the names of its contributors may be used 
#     to endorse or promote products derived from this software without 
#     specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR 
# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, 
# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, 
# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 
use DB_File ;

# for perl -w syntax check use lib "../lib/perl5lib" ;
require "fileutils.pl" ;
require "miscutils.pl" ;
require "ttmetrics.pl" ;
require "ttutils.pl" ;

$DEBUG = 0 ;

########################################################################
# REALLY NEED A REDESIGN.  There should be two main structures:        #
# metrics-per-object and metrics-per-module.  We should be able to     #
# completely fill the metrics-per-object structure first, using        #
# information from the metrics db that xxmlobjtxt generates plus       #
# stuff we figure out here, using the alllinks file as well.           #
########################################################################
# $objmetrics{$objectpath} = [ qwer, asdf, zxcv...]
# $modmetrics{$modpath} = [ QWER, ASDF, ZXCV... ]
# We'd define the two arrays of information more or less independently 

$sample =<<EOS;
ttr/APX/L2_MPP/324	2011-11-28 14:55:07,CreateModDate,0,,,,,1
EOS

$rootpathname = "ttr" ;
while (@ARGV) 
{ 
    $arg = shift ;
    if ($arg =~ /^-/)
    {
        $DEBUG++ if $arg =~ /^-d/ ;
    }
    else
    {
        $pname = $arg ;
    }
}
die "Usage:\n  $0 [-d] projectname\n" 
        unless defined $pname ;

$rootdirname = "$rootpathname/$pname" ; 
$htmlfilename = "$rootdirname/metrics.html" ;

$metricsdbfile = "LogsAndData/$pname.metrics.db" ;
print STDERR "metrics db file is '$metricsdbfile'\n" ;
tie %metricsdb, "DB_File", $metricsdbfile, O_RDWR, 0666, $DB_HASH
        or die "Couldn't open '$metricsdbfile': $!\n" ;

$linksfile = "$rootdirname/alllinks.txt" ;
print STDERR "links file is '$linksfile'\n" ;
open L, $linksfile or die "Couldn't open $linksfile for reading: $!\n" ;

# print "METRICS for $pname\n" ;
# printheaderrow() ;

# data node keys:
# DIRECT as calculated by xxmlobjtxt
#    MODDATE     modification date
#    ONUM        object number
#    PROJID      project id as opposed to DOORS id
#    ISSHALL     has a "shall" in the text
#    ISDELETED   is deleted: text starts with "Deleted:"
#    HASTBX      has TBD or TBC or TBS in the text, as a word
# DERIVED from above
#    ISREQUIREMENT  is in section 3 or above, 
#                   is not deleted, has projid not blank
#    CHILD_IS_DRDIRD
#    CHILD_IS_REQT
#    ERROR_ICD_ICD_LINK
#    ERROR_NO_STYPE
#    ERROR_NO_TTYPE
#    ERROR_REQT_VA_LINK
#    ERROR_VA_VA_LINK
#    ERROR_WRONG_WAY_VLINK
#    PARENT_IS_DRDICD
#    PARENT_IS_REQT
#    VA_VERIFIES_DRDIRD

foreach $node (sort keys %metricsdb)
{
    $noderecord = $metricsdb{$node} ;
# print "xmetrify: node=$node nodemetrics=$nodemetrics\n" ;
    ####################################################################
    # getnodedata should return a hash with all the node-specific      #
    # data in it, whether straight from the database or derived        #
    ####################################################################
    $nodedataref = getnodedata ($noderecord) ;
    $objmetrics{$node} = $nodedataref ;
}

########################################################################
# Now read links file into separate structure                          #
########################################################################
$sample=<<EOSL ;
/SMAP/VnV/VAM_-_DO_NOT_BASELINE	489	t	/SMAP/L1_RMS	78
EOSL
@modules = sort keys %totalcount ;
# print "keys of totalcount are @modules\n" ;
while (<L>)
{
    chomp ;
    # don't include leading slashes, because objects don't have them
    next unless /^\/(.*)\t(\d+)\tt\t\/(.*)\t(\d+)$/ ;
    ($smod, $snum, $tmod, $tnum) = ($1, $2, $3, $4) ;
    $smod = "ttr/$smod" ;
    $tmod = "ttr/$tmod" ;
# print "smod=$smod snum=$snum tmod=$tmod tnum=$tnum\n" ;
    $snode = "$smod/$snum" ;
    $tnode = "$tmod/$tnum" ;
    next unless     defined($objmetrics{$snode}) 
                and defined($objmetrics{$tnode}) ;
    $snoderef = $objmetrics{$snode} ;
    $tnoderef = $objmetrics{$tnode} ;
    # print "snode= $snode tnode=$tnode snoderef=$snoderef tnoderef=$tnoderef\n" ;
    #    if (!defined($objmetrics{$snode}) or !defined($objmetrics{$tnode})) ;
    
    # OOPS we need to count things only if legit requirements.  Right?
    # but remember, VAs for the most part do not have TMT IDs.  So 
    # they're legit without having a TMT ID.  Shoot.  So first figure 
    # out if each is legit requirement, interface, or VA 
    ($sisDRD, $sisICD, $sisVAM) = getModTypeBooleans($smod) ;
    ($tisDRD, $tisICD, $tisVAM) = getModTypeBooleans($tmod) ;
    
    if ($snode eq $tnode)
    {
        $snoderef->{"ERROR_LINK_TO_SELF"}++ ;
    }
    elsif ($smod eq $tmod) 
    {
        # should be OK to count just one.  Don't care about both directions 
        # when summing. 
        $snoderef->{"LINK_TO_SAME_MOD"}++ ;
    }
    else
    {
        ################################################################
        # not a self link, so count ins and outs.  Remember, the       #
        # source of a link is the lower level link, so flowdown goes   #
        # from target to source.  DOORS is dumb that way.              #
        ################################################################
        # first set info for source, then for target.  Keep it simple.
        if  ($sisDRD)
        {
            if      ($tisDRD) { $snoderef->{"PARENT_IS_DRDICD"}++ ; }
            elsif   ($tisICD) { $snoderef->{"PARENT_IS_DRDICD"}++ ; }
            elsif   ($tisVAM) { $snoderef->{"ERROR_REQT_VA_LINK"}++ ; }
            else              { $snoderef->{"ERROR_NO_TTYPE"}++ ; }
        }
        elsif ($sisICD)
        {
            if      ($tisDRD) { $snoderef->{"PARENT_IS_REQT"}++ ; }
            elsif   ($tisICD) { $snoderef->{"ERROR_ICD_ICD_LINK"}++ ; }
            elsif   ($tisVAM) { $snoderef->{"ERROR_REQT_VA_LINK"}++ ; }
            else              { $snoderef->{"ERROR_NO_TTYPE"}++ ; }
        }
        elsif ($sisVAM)
        {
            if      ($tisDRD) { $snoderef->{"VA_VERIFIES_DRDICD"}++ ; }
            elsif   ($tisICD) { $snoderef->{"VA_VERIFIES_DRDICD"}++ ; }
            elsif   ($tisVAM) { $snoderef->{"ERROR_VA_VA_LINK"}++ ; }
            else              { $snoderef->{"ERROR_NO_TTYPE"}++ ; }
        }
        
        # Now look at targets.  Same deal different results here and 
        # there .  Should we distinguish VA_VERIFIES vs VI_VERIFIED_BY ?
        if  ($tisDRD)
        {
            if      ($sisDRD) { $tnoderef->{"CHILD_IS_DRDIRD"}++ ; }
            elsif   ($sisICD) { $tnoderef->{"CHILD_IS_DRDIRD"}++ ; }
            elsif   ($sisVAM) { $tnoderef->{"VA_VERIFIES_DRDIRD"}++ ; }
            else              { $tnoderef->{"ERROR_NO_STYPE"}++ ; }
        }
        elsif ($tisICD)
        {
            if      ($sisDRD) { $tnoderef->{"CHILD_IS_REQT"}++ ; }
            elsif   ($sisICD) { $tnoderef->{"ERROR_ICD_ICD_LINK"}++ ; }
            elsif   ($sisVAM) { $tnoderef->{"VA_VERIFIES_DRDIRD"}++ ; }
            else              { $tnoderef->{"ERROR_NO_STYPE"}++ ; }
        }
        elsif ($tisVAM)
        {
            if      ($sisDRD) { $tnoderef->{"ERROR_WRONG_WAY_VLINK"}++ ; }
            elsif   ($sisICD) { $tnoderef->{"ERROR_WRONG_WAY_VLINK"}++ ; }
            elsif   ($sisVAM) { $tnoderef->{"ERROR_VA_VA_LINK"}++ ; }
            else              { $tnoderef->{"ERROR_NO_STYPE"}++ ; }
        }
        
    }
                          


    ################################################################
    # now levels        WE DON'T DO THIS ANY MORE                  #
    ################################################################
    # $slevel = getmodlevel ($snode) ;
    # $tlevel = getmodlevel ($tnode) ;
    # if ($slevel >= 0 and $tlevel >= 0 and 
    #         abs($tlevel-$slevel) > 1
    #      )  # then it's a skip level
    # {
    #     $snoderef->[$MOBJ_FLOWDOWNSINSKIPLEVEL]++ ;
    #     $tnoderef->[$MOBJ_FLOWDOWNSOUTSKIPLEVEL]++ ;
    # }
    ################################################################        

}
close L ;

@DRDlist = [ ] ;
@ICDlist = [ ] ;
@VAMlist = [ ] ;

# Now for the sums
foreach $node (sort keys %metricsdb)
{
# print STDERR "node=$node\n" ;
    $noderef = $objmetrics{$node} ;
    $modname = getModnameOnly($node) ;
    ($isDRD, $isICD, $isVAM) = getModTypeBooleans($node) ;
    

# print STDERR "node=$node modname = $modname\n" ;
    if (!defined($modmetrics{$modname}))
    {
        $mmref = initModMetrics() ;
        $modmetrics{$modname} = $mmref ;
        if ($isDRD) { push @DRDlist, $modname ; }
        elsif ($isICD) { push @ICDlist, $modname ; }
        elsif ($isVAM) { push @ICDlist, $modname ; }
        else { warn "UNKNOWN MODULE TYPE FOR object $modname\n" ; }
    }
    else
    {
        $mmref = $modmetrics{$modname} ;
    }
    
    # First do the common stuff.  Little enough of that.
    # module name is the key of the hash
    $mmref->{"NUM_OBJECTS"}++ ;
    $mmref->{"LINKS_WITHIN_MODULE"}++ if $noderef{"LINK_TO_SAME_MOD"} ;
    $mmref->{"TBXes"}++ if $noderef{"HASTBX"} ;
    $mmref->{"DATE_LAST_MOD"} = $noderef{"LINK_TO_SAME_MOD"} 
            if $noderef{"LINK_TO_SAME_MOD"} gt $mmref{"DATE_LAST_MOD"} ;

    # OK, now we differentiate by type
    if ($isDRD)
    {
        $mmref->{"REQS_WITH_PARENTS"}++ if $nodref->{"PARENT_IS_DRDICD") ;
        $mmref->{"REQS_WITH_CHILDREN"}++ if $noderef->{"CHILD_IS_DRDICD") ;
        $mmref->{"VA_LINKS"}++ if $noderef->{"VA_VERIFIES_DRDICD") ;
    }
    elsif ($isICD)
    {
        $mmref->{"INTERFACES_WITH_PARENTS"}++ if $noderef->{"PARENT_IS_REQT"} ;
        # we are omitting child is requiremnt for ICDs
        $mmref->{"VA_LINKS"}++ if $noderef->{"VA_VERIFIES_DRDICD"}
    }
    elsif ($isVAM)
    {
        $mmref->{"VAS_WITH_PARENTS"}++ if $noderef->{"VA_VERIFIES_DRDICD"} ;
    }
    else
    {
        warn "UNKNOWN MODULE TYPE FOR object $node\n" ;
    }
    # Here's where we ought to put error messages from the node...
}

$reportdate = `date` ;
chomp $reportdate ;
print STDERR "Opening html file '$htmlfilename'\n" ;
open H, "> $htmlfilename"
        or die "Couldn't open '$htmlfilename' for writing: $!\n" ;
print H htmlheader("Metrics for $pname") ;
print H "<H2>Metrics for $pname generated $reportdate</H2>\n" ;
print H <<EOX
<p><strong>Note:</strong> the \"modify date\" column is based 
 on the modification date of the object text, or module baseline
 date of object text is mod date is not available.</p>
EOX

print H "<H3"DRD METRICS</H3>\n" ;
@drdheaders = ["Module", "# Objects", "# Requirements with Parents",
        "# Requirements with Children", "# Links within Module",
        "# Requirements with TBx", "# Links from VAM",
        "Date of Last Modification" ]
print H "<table border=1>\n" ;
print H "<tr><th>" . join("</th><th>", "Module", @drdheaders) . "</th></tr>\n" ;
foreach $modname (@DRDlist)
{
    %mmref = $modmetrics{$modname};
    @row = () ;
    ($pmodname = $modname) =~ s/^ttr\/$pname\/// ;
    
    push @row, "$pmodname" ;
    push @row, $mmref->{"NUM_OBJECTS"} ;
    push @row, $mmref->{"REQS_WITH_PARENTS"} ;
    push @row, $mmref->{"REQS_WITH_CHILDREN"} ;
    push @row, $mmref->{"LINKS_WITHIN_MODULE"} ;
    push @row, $mmref->{"TBXes"} ;
    push @row, $mmref->{"VA_LINKS"} ;
    push @row, $mmref->{"DATE_LAST_MOD"} ;
    # only the first row is not right-aligned, OK?
    print H "<tr><td>" . join ("</td><td align=right>", @row) . "</td></tr>\n" ;
}
print H "</table>\n" ;
print H "</body></html>\n" ;
close H ;

########################################################################
# returns module level if there's a substring of the form '/Ln-' or    #
# '/Ln_', or if the modname begins with Ln- or Ln_; else returns -1    #
########################################################################
sub getmodlevel # ($modulename)  
{
    my ($modname) = @_ ;
    my $level = -1 ;
    if ($modname =~ /\/L(\d)[_\-]/) { $level = $1 ; }
    elsif ($modname =~ /^L(\d)[_\-]/) { $level = $1 ; }
    print STDERR "module is '$modname'\tlevel $level\n" if $DEBUG ;
    return $level ;
}

sub formatdate # (dateint)
{
    my ($dateint) = @_ ;
    my ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) 
        = localtime(int($dateint)) ;
    $mon++ ;
    $year+= 1900 ;
    # $result = sprintf "%04d-%02d-%02d %02d:%02d:%02d", $year, $mon, $mday, $hour, $min, $sec ;
    $result = sprintf "%04d-%02d-%02d", $year, $mon, $mday ;
    return $result ;
}

sub initModMetrics # ()
{
    my $mmref = { } ;
    
    $mmref->{"NUM_OBJECTS"} = 0 ;
    $mmref->{"REQS_WITH_PARENTS"} = 0 ;
    $mmref->{"REQS_WITH_CHILDREN"} = 0 ;
    $mmref->{"INTERFACES_WITH_PARENTS"} = 0 ;
    $mmref->{"VAS_WITH_PARENTS"} = 0 ;
    $mmref->{"LINKS_WITHIN_MODULE"} = 0 ;
    $mmref->{"TBXes"} = 0 ;
    $mmref->{"VA_LINKS"} = 0 ;
    $mmref->{"DATE_LAST_MOD"} = "1971-01-01 00:00:01" ;
    return $mmref ;
}
    